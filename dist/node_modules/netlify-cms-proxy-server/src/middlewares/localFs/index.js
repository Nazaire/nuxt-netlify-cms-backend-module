"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const joi_1 = require("../joi");
const customValidators_1 = require("../joi/customValidators");
const fs_1 = require("../utils/fs");
const entries_1 = require("../utils/entries");
exports.localFsMiddleware = ({ repoPath }) => {
    return async function (req, res) {
        try {
            const { body } = req;
            switch (body.action) {
                case 'info': {
                    res.json({
                        repo: path_1.default.basename(repoPath),
                        // eslint-disable-next-line @typescript-eslint/camelcase
                        publish_modes: ['simple'],
                        type: 'local_fs',
                    });
                    break;
                }
                case 'entriesByFolder': {
                    const payload = body.params;
                    const { folder, extension, depth } = payload;
                    const entries = await fs_1.listRepoFiles(repoPath, folder, extension, depth).then(files => entries_1.entriesFromFiles(repoPath, files.map(file => ({ path: file }))));
                    res.json(entries);
                    break;
                }
                case 'entriesByFiles': {
                    const payload = body.params;
                    const entries = await entries_1.entriesFromFiles(repoPath, payload.files);
                    res.json(entries);
                    break;
                }
                case 'getEntry': {
                    const payload = body.params;
                    const [entry] = await entries_1.entriesFromFiles(repoPath, [{ path: payload.path }]);
                    res.json(entry);
                    break;
                }
                case 'persistEntry': {
                    const { entry, assets } = body.params;
                    await fs_1.writeFile(path_1.default.join(repoPath, entry.path), entry.raw);
                    // save assets
                    await Promise.all(assets.map(a => fs_1.writeFile(path_1.default.join(repoPath, a.path), Buffer.from(a.content, a.encoding))));
                    res.json({ message: 'entry persisted' });
                    break;
                }
                case 'getMedia': {
                    const { mediaFolder } = body.params;
                    const files = await fs_1.listRepoFiles(repoPath, mediaFolder, '', 1);
                    const mediaFiles = await Promise.all(files.map(file => entries_1.readMediaFile(repoPath, file)));
                    res.json(mediaFiles);
                    break;
                }
                case 'getMediaFile': {
                    const { path } = body.params;
                    const mediaFile = await entries_1.readMediaFile(repoPath, path);
                    res.json(mediaFile);
                    break;
                }
                case 'persistMedia': {
                    const { asset } = body.params;
                    await fs_1.writeFile(path_1.default.join(repoPath, asset.path), Buffer.from(asset.content, asset.encoding));
                    const file = await entries_1.readMediaFile(repoPath, asset.path);
                    res.json(file);
                    break;
                }
                case 'deleteFile': {
                    const { path: filePath } = body.params;
                    await fs_1.deleteFile(repoPath, filePath);
                    res.json({ message: `deleted file ${filePath}` });
                    break;
                }
                case 'getDeployPreview': {
                    res.json(null);
                    break;
                }
                default: {
                    const message = `Unknown action ${body.action}`;
                    res.status(422).json({ error: message });
                    break;
                }
            }
        }
        catch (e) {
            console.error(`Error handling ${JSON.stringify(req.body)}: ${e.message}`);
            res.status(500).json({ error: 'Unknown error' });
        }
    };
};
exports.getSchema = ({ repoPath }) => {
    const schema = joi_1.defaultSchema({ path: customValidators_1.pathTraversal(repoPath) });
    return schema;
};
exports.registerMiddleware = async (app) => {
    const repoPath = path_1.default.resolve(process.env.GIT_REPO_DIRECTORY || process.cwd());
    app.post('/api/v1', joi_1.joi(exports.getSchema({ repoPath })));
    app.post('/api/v1', exports.localFsMiddleware({ repoPath }));
    console.log(`Netlify CMS File System Proxy Server configured with ${repoPath}`);
};
